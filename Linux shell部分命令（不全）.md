# Linux shell部分命令

## 管理文件和目录

| 命令             | 描述                                                         | 相关                                                         |
| ---------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| `man CMD`        | 获取特定命令的帮助文档                                       | `Enter`键逐行查看，空格键翻页，按`q`退出。<br>可选项`-k`：使用关键字查找<br>手册页有不同的节，从1到9，通常显示编号最低的节 |
| `pwd`            | 获取当前工作目录                                             |                                                              |
| `ls`             | 获取文件列表                                                 | 可选项`-F`：区分文件和目录。目录名用“/”表示，可执行文件用“\*”表示<br>可选项`-a`：列出所有文件，包括隐藏文件<br>可选项`-R`：递归选项，列出当前目录下的子目录的文件<br>可选项`-l`：产生长列表格式的输出<br>可选项`-d`：仅查看目录本身，不查看其中内容<br>可选项`-i`：查看指定文件的inode编号，该编号是文件的唯一标识<br>可选项`-d`：只显示目录，不显示目录内容<br />可选项`-sh`：以人类易读的格式显示文件大小<br />可选项`-g`：在文件长列表中不显示文件属主<br />可选项`-o`：在文件长列表中不显示文件属组<br />可以使用通配符匹配，常用的包括`?`、`*`、`!`、`[]`等 |
| `touch FILENAME` | 修改已有文件的日期和时间（或创建不存在的空文件，初始大小为0） |                                                              |
| `cp SRC DES`     | 复制文件到指定位置                                           | 可选项`-i`：强制shell询问是否需要覆盖已有文件<br>在参数为文件夹时需要在末尾添加“`/`”<br>可选项`-R`：递归复制整个目录的内容，`DES`参数中的文件夹如果不存在则自动创建 |
| `ln -s`          | 创建软链接（符号链接）                                       | 软链接是一个独立的文件，该文件指向另一个文件，彼此内容并不相同；而硬链接创建的文件和源文件是同一个文件<br>只能对处于同一存储设备的文件创建硬链接，否则必须使用符号链接 |
| `mv SRC DES`     | 将文件和目录移动到指定位置或重新命名                         | `mv`只影响文件名，不会影响inode编号和时间戳<br>可选项`-i`：强制shell询问是否需要覆盖已有文件 |
| `rm FILENAME`    | 删除指定文件                                                 | 可选项`-i`：强制shell询问是否需要删除该文件<br>可选项`-f`：强制删除文件<br>可选项`-r`：删除目录中的文件，再删除目录本身<br>可选项`-rf`：直接删除指定目录及其所有内容 |
| `mkdir DIR`      | 创建指定目录                                                 | 可选项`-p`：批量创建目录和其下的子目录                       |
| `rmdir DIR`      | 删除指定目录                                                 | 该命令默认只删除空目录，要删除非空目录须使用`rm -r`          |
| `file FILENAME`  | 探测文件内部并判断文件类型                                   | 对软链接，该命令可以说明链接到的目标文件<br>对二进制可执行程序，该命令可以确定其编译时所面向的平台以及需要何种类型的库 |
| `cat FILENAME`   | 显示文本文件中所有数据                                       | 可选项`-n`：给所有行（包括空行）加上行号<br>可选项`-b`：只给非空行加上行号 |
| `more FILENAME`  | 显示文本文件中所有数据，但会在显示每页数据后暂停             |                                                              |
| `less FILENAME`  | 显示文本文件中所有数据，但会在显示每页数据后暂停             | 该命令相较于`more`拥有更多特性，并且可以在完成整个文件的读取之前显示文件的内容 |
| `tail FILENAME`  | 显示文件最后几行的内容，默认为10行                           | 可选项`-n`：修改所显示的行数，形式为`-n NUM`或`-NUM`<br>可选项`-f`：允许在其他进程使用此文件时查看并动态修改文件内容，常用于实时监测系统日志 |
| `head FILENAME`  | 显示文件开头几行的内容，默认为10行                           | 可选项`-n`：修改所显示的行数，形式为`-n NUM`或`-NUM`<br/>    |
| `locate`         | 查找文件                                                     |                                                              |
| `updatedb`       | 更新系统数据库                                               |                                                              |
| `which`          | 获取查找程序位置                                             | 只显示外部命令文件                                           |
| `find`           | 高级递归查找文件                                             | 命令格式`find / -name foo -print`                            |

## 进程、命令管理

| 命令                       | 描述                                                   | 相关                                                         |
| -------------------------- | ------------------------------------------------------ | ------------------------------------------------------------ |
| `ps`                       | 获取静态进程列表                                       | `ps`命令有3种类型：Unix风格、BSD风格和GNU风格<br>可选项`-ef`：查看系统中运行的所有进程（`-e`指定显示所有进程，`-f`扩充输出内容）<br>可选项`-l`：产生长格式输出<br>可选项`--forest`：以树状查看进程<br />可选项`-e`或`-A`：显示所有进程 |
| `top`                      | 获取动态进程列表                                       | `top`命令运行时，<br>键入`f`：选择用于对输出进行排序的字段（默认为%CPU），同时也能查看各字段全称<br>键入`d`：修改轮询间隔<br>键入`q`：退出`top` |
| `kill PID`                 | 向进程发送信号，默认值为15（TERM信号）                 | 可选项`-s`：支持指定其他信号（用信号名或信号值）<br>可选项`-l`：获取所有信号和数字值<br>可选项`-#`：向特定进程发送特定信号 |
| `killall PID/NAME`         | 向进程发送信号，可使用进程名称                         |                                                              |
| `pkill NAME`               | 使用程序名代替PID来终止进程                            | 允许使用通配符                                               |
| `echo $0`                  | 显示当前shell的名称                                    | 如果该命令在shell脚本内运行，则会显示脚本名称                |
| `echo $SHELLNAME_SUBSHELL` | 显示是否生成子shell                                    | 其中的SHELLNAME需要替换成当前shell，例如当前为zsh，则命令为`echo $ZSH_SUBSHELL`<br>如果返回0则没有子shell，非0则存在子shell |
| `sleep SEC`                | 希望进程睡眠相应秒数                                   | 可选项`&`：紧跟在`SEC`参数后，表示将命令置入后台模式         |
| `jobs`                     | 显示当前运行在后台模式中属于当前用户的所有进程（作业） | 可选项`-l`：查看更多相关信息<br>如果有多个后台进程在运行，最近启动的作业在其作业号之后会有一个加号（+），在它之前启动则以减号（-）显示。带有加号的作业为默认作业 |
| `coproc CMD`               | 在后台生成一个子shell并在其中执行命令                  | 该命令会默认将进程命名为COPROC。使用扩展语法可以自定义名称：`coproc NAME { CMD; }` |
| `type CMD`                 | 查询某个命令是否为内建命令                             | 可选项`-a`：查看同一种命令的不同实现                         |
| `history`                  | 显示最近用过的命令列表                                 | 通过修改HISTSIZE环境变量可以设置保存在历史记录中的命令数量，默认为1000<br>可选项`-a`：在不退出shell的情况下强制将命令历史记录写入.SHELL_history文件<br>可选项`-n`：强制重新读取.SHELL_history文件，更新内存中的终端会话历史记录<br>可选项`-c`：清除命令历史，与`-a`结合使用可以清除.SHELL_history文件 |
| `!!`                       | 唤回并重用最近的命令                                   |                                                              |
| `!NUM`                     | 唤回并重用指定编号的命令                               |                                                              |
| `alias NAME='CMD'`         | 允许为常用命令及其参数创建别名                         | 可选项`-p`：查看当前可用的别名                               |
| `unalias NAME`             | 删除指定别名                                           | 如果被删除的别名不是手动设置的，那么下次重新登录系统就会再次出现。可以通过修改环境文件永久删除某个别名 |
| `apropos CMD`              | 获取特定命令的相关命令                                 |                                                              |

`echo`命令的可选项`-n`表示去掉换行符。

## 监测磁盘空间

| 命令                  | 描述                                             | 相关                                                         |
| --------------------- | ------------------------------------------------ | ------------------------------------------------------------ |
| `mount`               | 挂载存储设备                                     | 可选项`-t`：指定文件系统类型并过滤输出结果<br>手动挂载命令：`mount -t type device directory`，但这种方法只能实现临时挂载。要强制Linux在启动时自动挂载文件系统，可以将其添加到`/etc/fstab`文件中<br>可选项`-o`：允许在挂载文件系统时添加一系列以逗号分隔的额外选项 |
| `umount [dir/device]` | 卸载存储设备                                     |                                                              |
| `df`                  | 查看所有已挂载磁盘的使用情况                     | 可选项`-t`：指定文件系统类型并过滤输出结果<br>可选项`-h`：以人类易读格式显示磁盘空间 |
| `du`                  | 显示某个特定目录（默认是当前目录）的磁盘使用情况 | 可选项`-c`：显示所有已列出文件的总大小<br>可选项`-h`：按人类易读格式输出大小<br>可选项`-s`：输出每个参数的汇总信息 |

## 处理数据文件

| 命令                | 描述                                       | 相关                                                         |
| ------------------- | ------------------------------------------ | ------------------------------------------------------------ |
| `sort`              | 依据默认语言的排序规则对数据进行排序       | 可选项`-n`：将数字按值排序<br>可选项`-M`：将数字按月份排序<br>可选项`-t x -k NUM`：`-t`指定分隔符，`-k`指定排序字段序号 |
| `grep STR FILENAME` | 在指定文件中逐行搜索字符串                 | 可选项`-v`：反向搜索（不匹配指定模式的行）<br>可选项`-n`：显示匹配指定模式的行号<br>可选项`-c`：输出匹配指定模式的总行数<br>可选项`-E STR1 -E STR2`：指定多个匹配模式<br>可选项`-r`：递归搜索所有目录下的特定字符串<br>`grep`默认使用Unix风格正则表达式来匹配模式<br>`egrep`是`grep`的衍生，支持POSIX扩展正则表达式<br>`fgrep`支持将匹配模式指定为以换行符为分隔的一系列固定长度的字符串 |
| `gzip`              | 压缩指定文件                               | 也可指定多个文件名或用通配符来一次性压缩多个文件             |
| `gunzip`            | 解压指定文件                               |                                                              |
| `tar`               | 打包、压缩、归档文件，也可以将输出写入文件 | 可选项`-cvf TAR NAME1 NAME2`：创建归档文件（`-c`），包括指定的文件或目录<br>可选项`-tf TAR`：列出但不提取指定tar文件的内容<br>可选项`-xvf TAR`：从tar文件中提取内容<br>可选项`-zxvf FILENAME.tgz`：提取经`gzip`压缩过的tar文件 |

## 环境变量

| 命令                     | 描述                                        | 相关                                                         |
| ------------------------ | ------------------------------------------- | ------------------------------------------------------------ |
| `env`或`printenv`        | 查看全局变量                                | `printenv KEY`命令可以显示个别环境变量的值，`env`没有这个用法，但`env KEY=VALUE`可以为新的环境变量设置值。两者都不会对变量结果进行排序 |
| `echo $KEY`              | 查看某个环境变量的值                        | `$KEY`作用是引用该变量的值，并且它还可以作为其他命令的参数（类似C语言的指针），例如`ls $KEY` |
| `set`                    | 显示特定进程的所有环境变量                  | 同时按字母顺序对变量结果进行排序                             |
| `key=value`              | 创建仅对该shell进程可见的局部用户自定义变量 | 如果用于赋值的字符串包含空格，则必须用单引号或双引号来界定该字符串的起止。在变量名、等号和值之间没有空格 |
| `key=(value1 value2...)` | 为某个环境变量设置多个值                    | 要引用单个数组元素必须使用表示在其数组位置的索引，索引通常以0开始（但在zsh中以1开始）<br>显示整个数组变量可以用通配符\*作为索引：`echo ${key[*]}`<br>改变某个索引的值：`key[index]=value`<br>删除数组中的某个值及其索引：`unset key[index]`，这个命令将值与其索引一并删去，因此该索引对应空值 |
| `export key`             | 导出局部变量成为全局变量                    | 可以将设置变量和导出变量合并为同一个命令：`export key=value`。子shell中导出的全局变量不能影响父shell中同名全局变量的值 |
| `unset key`              | 删除已有的环境变量                          | 在子进程中删除全局环境变量不会影响到父进程中的同名变量       |
| `PATH=$PATH:path`        | 在PATH变量末尾添加新变量                    |                                                              |

## 用户管理

| 命令              | 描述                                                 | 相关                                                         |
| ----------------- | ---------------------------------------------------- | ------------------------------------------------------------ |
| `useradd`         | 创建用户并设置用户的`$HOME`结构                      | 可选项`-D`：查看所使用的Linux发行版的系统默认值，使用`useradd -D -#`还可更改默认值<br>可选项`-m`：创建`$HOME`目录 |
| `userdel`         | 删除用户                                             | 默认只删除`/etc/passwd`和`/etc/shadow`文件中的用户信息，属于该账户的文件会被保留<br>可选项`-r`：删除用户的`$HOME`目录和邮件目录 |
| `usermod`         | 修改用户账户信息                                     | 可选项`-c`：修改备注字段<br>可选项`-e`：修改过期日期<br>可选项`-g`：修改默认的登录组<br>可选项`-G GROUP USERNAME`：向组添加用户<br>可选项`-l`：修改用户账户的登录名<br>可选项`-L`：锁定账户，禁止用户登录<br>可选项`-p`：修改账号密码<br>可选项`-U`：解除锁定，恢复用户登录 |
| `passwd`          | 修改用户密码                                         | 只有root用户才能修改其他用户的密码<br>可选项`-e`：强制用户下次登录时修改密码 |
| `chpasswd`        | 修改一系列登录名和密码，自动加密并为用户账户设置密码 | 这些登录名-密码对以冒号分隔                                  |
| `chsh`            | 修改默认的用户登录shell                              | 必须用shell的全路径作为参数，不能只用shell名<br>可选项`-s`：指定新的shell名，若留空或不使用该可选项则指定当前登录shell |
| `chfn`            | 在`/etc/passwd`文件的备注字段中保存信息              | 使用`finger`命令查看Linux的用户信息                          |
| `chage`           | 管理用户账户的有效期                                 | 可选项`-E`：设置密码过期日期<br>可选项`-I`：设置密码过期多少天后锁定账户<br>可选项`-m`：设置更改密码的最小间隔天数<br>可选项`-M`：设置密码的最大有效天数 |
| `groupadd`        | 新建组                                               |                                                              |
| `groupmod`        | 修改已有组信息                                       | 可选项`-g`：修改已有组的UID<br>可选项`-n`：修改已有组的组名，保持UID不变 |
| `passwd`          | 设置密码                                             |                                                              |
| `passwd USERNAME` | 以root用户身份修改其他用户的密码                     |                                                              |

## 文件权限

| 命令                   | 描述                      | 相关                                                         |
| ---------------------- | ------------------------- | ------------------------------------------------------------ |
| `umask (xxx)`          | 显示和设置默认权限掩码    | 用全权限值（文件是666，目录和可执行文件是777）减去umask值得到实际的文件权限 |
| `chmod xxx FILENAME`   | 修改文件权限              | 权限值设置也可使用第二种形式：`[ugoa][+-=][rwxXstugo...]`。<br>第一组字符中，`u`=user，`g`=group，`o`=others，`a`=all<br>第二组字符中，`+`表示增加权限，`-`表示移除权限，`=`表示设置权限<br>第三组字符中，`X`表示仅当对象是目录或者已有执行权限时才赋予执行权限，`s`表示在执行时设置SUID或SGID（其中SGID用于共享文件），`t`表示设置**粘滞位**，`u`表示设置属主权限，`g`表示设置属组权限，`o`表示设置其他用户权限<br>例如`chmod o+r FILENAME`表示为其他用户添加读取权限<br>可选项`-R`：以递归方式修改文件和目录的权限 |
| `chown NAME FILENAME`  | 修改文件的属主            | `chown NAME.GROUP FILENAME`修改文件的属主和属组；<br>`chown .GROUP FILENAME`修改文件的属组<br>`chown NAME. FILENAME`在组名和用户登录名相同时可修改文件的属主和属组<br>可选项`-R`：递归修改子目录和文件的所属关系<br>可选项`-h`：修改文件的所有符号链接文件的所属关系<br>只有root用户能修改文件的属主。任何用户都可以修改文件的属组，但前提是该用户必须是原属组和新属组的成员 |
| `chgrp GROUP FILENAME` | 修改文件或目录的默认属组  |                                                              |
| `getfacl`              | 查看分配给文件或目录的ACL | ACL全称访问控制列表，允许指定包含多个用户或组的列表以及为其分配的权限。文件权限列末尾有加号（+）时表示该文件应用了ACL |
| `setfacl`              | 为用户或组分配权限        | 可选项`-m`：修改分配给文件或目录的权限<br>可选项`-x`：删除特定权限<br>语法：`u[ser]:uid:perms`<br>`g[roup]:gid:perms`<br>`o[ther]::perms`<br>对于uid或gid，可以使用数字值或名称<br>在规则定义前加上`d:`可设置目录的默认ACL |

## 文件系统

| 命令       | 描述                              | 相关                                                         |
| ---------- | --------------------------------- | ------------------------------------------------------------ |
| `fdisk`    | 在存储设备上创建和管理分区        | 只能处理最大2TB的硬盘，且不允许调整现有分区的大小，只能先删除现有分区再重建。该命令有自己的命令行可选项<br>可选项`d`：删除分区<br>可选项`n`：添加一个新分区<br>可选项`p`：显示当前分区表<br>可选项`q`：退出，不保存更改<br>可选项`w`：将分区表写入磁盘并退出 |
| `gdisk`    | 采用GUID分区表创建和管理分区      | `gdisk`与`fdisk`命令相似                                     |
| `parted`   | 使用另一种命令行管理分区          | GNU parted允许调整现有分区大小                               |
| `lsblk -f` | 显示新近格式化过并挂载的分区      |                                                              |
| `fsck`     | 检查和修复大部分Linux文件系统类型 | 使用该命令前必须卸载设备<br>可选项`-t`：指定要检查的文件系统类型 |

一些发行版在创建好分区后不会通知Linux，此时需要使用`partprobe`命令或`hdparm`命令，或重启系统。

在将数据存储到分区之前必须使用某种文件系统对其进行格式化，以便Linux能够使用分区。随后将其挂载到虚拟目录中的某个挂载点，以便在新分区中存储数据。

## 逻辑卷管理器LVM

| 命令        | 描述                                              | 相关                                                         |
| ----------- | ------------------------------------------------- | ------------------------------------------------------------ |
| `pvcreate`  | 指定一个未使用的磁盘分区（或整个驱动器）由LVM使用 |                                                              |
| `vgcreate`  | 将PV加入存储池，后者用于构建各种逻辑卷            | 被指定为PV的分区只能属于单个VG，但不同于该分区的其他分区可以属于其他VG |
| `lvcreate`  | 构建逻辑卷LV                                      | LV由VG的存储空间块（physical extents）PE组成，可以挂载并作为普通磁盘分区使用。LV只能从一个指定的VG创建，但多个LV可以共享单个VG<br>可选项`-L`：设置LV的大小 |
| `lvdisplay` | 显示LV相关信息                                    | LV需要用绝对路径表示<br>也可用`lvs`或`lvscan`命令            |
| `vgextend`  | 将PV加入VG                                        |                                                              |
| `vgreduce`  | 从VG中删除PV                                      |                                                              |
| `lvextend`  | 扩大LV的容量                                      |                                                              |
| `lvreduce`  | 收缩LV的容量                                      |                                                              |
| `lvm help`  | 显示所有的LVM命令                                 |                                                              |

## 软件包管理（基于Debian系统）

| 命令                     | 描述                                 | 相关                                                         |
| ------------------------ | ------------------------------------ | ------------------------------------------------------------ |
| `apt list`               | 显示仓库中所有可用的软件包           | 可选项`--installed`：仅输出已安装在系统中的软件包            |
| `apt show PKG`           | 显示特定软件包的详细信息             | 不会指明软件包是否已经安装                                   |
| `apt search`             | 查找特定的软件包                     | 该命令自带通配符效果，不需要添加通配符<br>可选项`--name-only`：只搜索软件包名称 |
| `apt update`             | 更新软件包数据库                     |                                                              |
| `apt upgrade`            | 更新系统中所有软件包                 | 该命令不会删除任何软件包。命令`apt full-upgrade`表示先删除某个软件包再升级 |
| `apt upgrade PKG`        | 更新特定软件包                       |                                                              |
| `apt install PKG`        | 下载特定软件包                       |                                                              |
| `apt remove PKG`         | 移除特定软件包                       | 该命令会保留数据和配置文件。命令`apt purge`删除软件包以及所有的相关的数据和配置文件 |
| `apt autoremove`         | 移除不再需要的软件包                 |                                                              |
| `dpkg`                   | 管理软件包                           |                                                              |
| `dpkg -l`                | 获取所有已安装软件包列表             |                                                              |
| `dpkg -L PKG`            | 列出与特定软件包相关的所有文件       |                                                              |
| `dpkg --search FILENAME` | 找出特定文件所属的软件包             | 文件要使用绝对路径                                           |
| `dpkg -i PACKAGENAME`    | 下载特定.deb软件包                   |                                                              |
| `dpkg -r PACKAGENAME`    | 删除特定软件包                       |                                                              |
| `dpkg -c FILENAME`       | 查看软件包内容（FILENAME是完整名称） |                                                              |
| `dpkg --force-install`   | 强制安装软件包                       |                                                              |

软件包存储在称为仓库（repository）的服务器上，仓库位置保存在`/etc/apt/sources.list`。在该文件中，指定仓库源的格式为：`deb(or deb-src address distribution_name PKG_type_list)`。`deb`或`deb-src`指定软件包的类型，`deb`表明这是一个已编译程序的仓库源，而`deb-src`表明这是一个源代码的仓库源。`address`是软件仓库的网址，`distribution_name`是该软件仓库的发行版的版本名称。`PKG_type_list`表明仓库里有什么类型的软件包，可能不止一个单词。

## 软件包管理（基于Red Hat系统）

| 命令                    | 描述                           | 相关                                                         |
| ----------------------- | ------------------------------ | ------------------------------------------------------------ |
| `dnf list installed`    | 列出系统中已安装的软件包       | 可以使用`> FILENAME`运算符将输出结果重定向到文件中           |
| `dnf provides FILENAME` | 找出安装该文件的软件包         |                                                              |
| `dnf install PKG`       | 安装特定软件包                 |                                                              |
| `dnf list upgrades`     | 查看已安装软件包的所有可用更新 |                                                              |
| `dnf upgrade`           | 升级系统中所有软件包           | 添加`PKG`参数表示升级特定软件包。命令`dnf upgrade-minimal`将软件包升级到最新的bug修复版或安全补丁版，而不是最新的最高版本 |
| `dnf remove PKG`        | 卸载软件包                     |                                                              |
| `dnf clean all`         | 处理损坏的依赖关系             | 也可使用`dnf repoquery --deplist PKG`命令，该命令显示软件包的所有依赖关系以及哪些软件包提供了这些依赖 |
| `dnf repolist`          | 查看当前拉取软件的仓库         | `dnf`仓库的定义存在于配置文件`/etc/dnf/dnf.conf`和`/etc/yum.repos.d`目录中的单独文件 |

## 应用程序容器：`snap`和`flatpak`

| 命令                   | 描述                                     | 相关                                                         |
| ---------------------- | ---------------------------------------- | ------------------------------------------------------------ |
| `snap version`         | 检查`snap`是否正在运行                   | 首次安装`snap`时需要使用命令`systemctl enable snapd.socket`和`systemctl start snapd.socket`启动`snap`服务 |
| `snap list`            | 查看当前已安装的`snap`应用程序列表       |                                                              |
| `snap list NAME`       | 在`snap`仓库中搜索指定程序               |                                                              |
| `snap info NAME`       | 查看`snap`应用程序（简称snap）的详细信息 |                                                              |
| `snap install`         | 安装新的`snap`                           | 安装时必须有root权限                                         |
| `snap remove NAME`     | 删除`snap`                               | 命令`snap disable`可以禁用`snap`，`snap enable`可以恢复`snap` |
| `flatpak list`         | 列出已安装的应用程序容器                 |                                                              |
| `flatpak search NAME`  | 搜索指定应用程序                         |                                                              |
| `flatpak install NAME` | 安装指定应用程序                         |                                                              |
| `flatpak uninstall`    | 删除应用程序容器                         |                                                              |

## 脚本重定向命令

| 命令     | 描述                                     | 相关                                                         |
| -------- | ---------------------------------------- | ------------------------------------------------------------ |
| `>`      | 将命令输出发送至文件                     |                                                              |
| `>>`     | 在文件末尾追加数据                       |                                                              |
| `<`      | 将文件内容作为输入发送至命令             |                                                              |
| `<<`     | 内联输入重定向符                         | 无须使用文件进行重定向，只需在命令行中指定用于输入重定向的数据 |
| `wc`     | 统计数据中的文本                         | 默认输出3个值，分别代表文本的行数、文本的单词数和文本的字节数 |
| `|`      | 将左侧的输出作为输入发送到右侧           |                                                              |
| `;`      | 一次性依次运行多个命令                   |                                                              |
| `{CMD;}` | 运行命令分组，尾部以分号结尾             |                                                              |
| `()`     | 将命令列表成为进程列表（命令分组的一种） |                                                              |

## 管理文件和目录

| 命令             | 描述                                                         | 相关                                                         |
| ---------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| `man COMMAND`    | 获取特定命令的帮助文档                                       | `Enter`键逐行查看，空格键翻页，按`q`退出。<br>可选项`-k`：使用关键字查找<br>手册页有不同的节，从1到9，通常显示编号最低的节 |
| `pwd`            | 获取当前工作目录                                             |                                                              |
| `ls`             | 获取文件列表                                                 | 可选项`-F`：区分文件和目录。目录名用“/”表示，可执行文件用“\*”表示<br>可选项`-a`：列出所有文件，包括隐藏文件<br>可选项`-R`：递归选项，列出当前目录下的子目录的文件<br>可选项`-l`：产生长列表格式的输出<br>可选项`-d`：仅查看目录本身，不查看其中内容<br>可选项`-i`：查看指定文件的inode编号，该编号是文件的唯一标识<br>可以使用通配符匹配，常用的包括?、\*、!、[]等 |
| `touch FILENAME` | 修改已有文件的日期和时间（或创建不存在的空文件，初始大小为0） |                                                              |
| `cp SRC DES`     | 复制文件到指定位置                                           | 可选项`-i`：强制shell询问是否需要覆盖已有文件<br>在参数为文件夹时需要在末尾添加“/”<br>可选项`-R`：递归复制整个目录的内容，`DES`参数中的文件夹如果不存在则自动创建 |
| `ln -s`          | 创建软链接（符号链接）                                       | 软链接是一个独立的文件，该文件指向另一个文件，彼此内容并不相同；而硬链接创建的文件和源文件是同一个文件<br>只能对处于同一存储设备的文件创建硬链接，否则必须使用符号链接 |
| `mv SRC DES`     | 将文件和目录移动到指定位置或重新命名                         | `mv`只影响文件名，不会影响inode编号和时间戳<br>可选项`-i`：强制shell询问是否需要覆盖已有文件 |
| `rm FILENAME`    | 删除指定文件                                                 | 可选项`-i`：强制shell询问是否需要删除该文件<br>可选项`-f`：强制删除文件<br>可选项`-r`：删除目录中的文件，再删除目录本身<br>可选项`-rf`：直接删除指定目录及其所有内容 |
| `mkdir DIR`      | 创建指定目录                                                 | 可选项`-p`：批量创建目录和其下的子目录                       |
| `rmdir DIR`      | 删除指定目录                                                 | 该命令默认只删除空目录，要删除非空目录须使用`rm -r`          |
| `file FILENAME`  | 探测文件内部并判断文件类型                                   | 对软链接，该命令可以说明链接到的目标文件<br>对二进制可执行程序，该命令可以确定其编译时所面向的平台以及需要何种类型的库 |
| `cat FILENAME`   | 显示文本文件中所有数据                                       | 可选项`-n`：给所有行（包括空行）加上行号<br>可选项`-b`：只给非空行加上行号 |
| `more FILENAME`  | 显示文本文件中所有数据，但会在显示每页数据后暂停             |                                                              |
| `less FILENAME`  | 显示文本文件中所有数据，但会在显示每页数据后暂停             | 该命令相较于`more`拥有更多特性，并且可以在完成整个文件的读取之前显示文件的内容 |
| `tail FILENAME`  | 显示文件最后几行的内容，默认为10行                           | 可选项`-n`：修改所显示的行数，形式为`-n NUM`或`-NUM`<br>可选项`-f`：允许在其他进程使用此文件时查看并动态修改文件内容，常用于实时监测系统日志 |
| `head FILENAME`  | 显示文件开头几行的内容，默认为10行                           | 可选项`-n`：修改所显示的行数，形式为`-n NUM`或`-NUM`<br/>    |
| `locate`         | 查找文件                                                     |                                                              |
| `updatedb`       | 更新系统数据库                                               |                                                              |
| `which`          | 获取查找程序位置                                             | 只显示外部命令文件                                           |
| `find`           | 高级递归查找文件（find / -name foo -print）                  |                                                              |

## 进程、命令管理

| 命令                       | 描述                                                   | 相关                                                         |
| -------------------------- | ------------------------------------------------------ | ------------------------------------------------------------ |
| `ps`                       | 获取静态进程列表                                       | `ps`命令有3种类型：Unix风格、BSD风格和GNU风格<br>可选项`-ef`：查看系统中运行的所有进程（`-e`指定显示所有进程，`-f`扩充输出内容）<br>可选项`-l`：产生长格式输出<br>可选项`--forest`：以树状查看进程 |
| `top`                      | 获取动态进程列表                                       | `top`命令运行时，<br>键入`f`：选择用于对输出进行排序的字段（默认为%CPU），同时也能查看各字段全称<br>键入`d`：修改轮询间隔<br>键入`q`：退出`top` |
| `kill PID`                 | 向进程发送信号，默认值为15（TERM信号）                 | 可选项`-s`：支持指定其他信号（用信号名或信号值）<br>可选项`-l`：获取所有信号和数字值<br>可选项`-#`：向特定进程发送特定信号 |
| `killall PID/NAME`         | 向进程发送信号，可使用进程名称                         |                                                              |
| `pkill NAME`               | 使用程序名代替PID来终止进程                            | 允许使用通配符                                               |
| `echo $0`                  | 显示当前shell的名称                                    | 如果该命令在shell脚本内运行，则会显示脚本名称                |
| `echo $SHELLNAME_SUBSHELL` | 显示是否生成子shell                                    | 其中的SHELLNAME需要替换成当前shell，例如当前为zsh，则命令为`echo $ZSH_SUBSHELL`<br>如果返回0则没有子shell，非0则存在子shell |
| `sleep SEC`                | 希望进程睡眠相应秒数                                   | 可选项`&`：紧跟在`SEC`参数后，表示将命令置入后台模式         |
| `jobs`                     | 显示当前运行在后台模式中属于当前用户的所有进程（作业） | 可选项`-l`：列出进程PID和作业号<br>可选项`-n`：只列出上次shell发出通知后状态发生改变的作业<br />可选项`-p`：只列出作业的PID<br />可选项`-r`：只列出运行中的作业<br />可选项`-s`：只列出已停止的作业<br>如果有多个后台进程在运行，最近启动的作业在其作业号之后会有一个加号（+），在它之前启动则以减号（-）显示。带有加号的是默认作业，只能存在一个；带减号的会在当前默认作业结束后成为下一个默认作业，也只能存在一个。 |
| `coproc CMD`               | 在后台生成一个子shell并在其中执行命令                  | 该命令会默认将进程命名为COPROC。使用扩展语法可以自定义名称：`coproc NAME { CMD; }` |
| `type CMD`                 | 查询某个命令是否为内建命令                             | 可选项`-a`：查看同一种命令的不同实现                         |
| `history`                  | 显示最近用过的命令列表                                 | 通过修改HISTSIZE环境变量可以设置保存在历史记录中的命令数量，默认为1000<br>可选项`-a`：在不退出shell的情况下强制将命令历史记录写入.SHELL_history文件<br>可选项`-n`：强制重新读取.SHELL_history文件，更新内存中的终端会话历史记录<br>可选项`-c`：清除命令历史，与`-a`结合使用可以清除.SHELL_history文件 |
| `!!`                       | 唤回并重用最近的命令                                   |                                                              |
| `!NUM`                     | 唤回并重用指定编号的命令                               |                                                              |
| `alias NAME='CMD'`         | 允许为常用命令及其参数创建别名                         | 可选项`-p`：查看当前可用的别名                               |
| `unalias NAME`             | 删除指定别名                                           | 如果被删除的别名不是手动设置的，那么下次重新登录系统就会再次出现。可以通过修改环境文件永久删除某个别名 |
| `apropos CMD`              | 获取特定命令的相关命令                                 |                                                              |

## 执行数学运算

| 命令            | 描述                       | 相关                                                         |
| --------------- | -------------------------- | ------------------------------------------------------------ |
| `expr`          | 在命令行中执行数学运算     | 早期命令，只能识别少量算术运算符和字符串运算符               |
| `$[expression]` | 用更简单的方法执行数学运算 | 同样在shell脚本内适用，但该方法不支持浮点运算                |
| `bc`            | 访问bash计算器             | 支持浮点运算<br />可选项`-q`：不显示欢迎信息<br />可选项`scale=NUM`：设置小数保留位数，默认为0<br />在脚本中使用`bc`的格式是：`$(echo "options; expression" | bc)` |
| `echo $?`       | 查看程序退出状态码         | 为0表示成功结束，为正整数表示因错误结束。其中，127表示无效命令，1表示无效参数 |
| `exit NUM`      | 指定一个退出状态码         | 也可使用变量作为参数，但最大值只能是255，当值超过255时shell自动通过模运算得到最终状态码 |

## 结构化命令

### 1. `if-then`语句

格式如下：

``````shell
if CMD
then
	CMDs
fi
``````

或是

```shell
if CMD; then
	CMDs
fi
```

在bash shell中，`if`语句后的命令如果成功执行，即退出状态码为0，则位于`then`部分的命令就会执行。`fi`语句表示`if-then`语句到此结束。

### 2. `if-then-else`和`if-then-elif-then`语句

格式如下：

```shell
if CMD
then
	CMDs
else
	CMDs
fi
```

当`if`语句中的命令返回非0状态码时，执行`else`语句中的命令。

还可使用`if-then-elif-then`语句将两个`if-then`语句相结合，但不能再使用`else`语句。如果`elif`语句返回0，则执行对应的`then`语句。格式如下：

```shell
if CMD
then
	CMDs
elif CMD2
then
	CMDs
fi
```

### 3. `test`命令和`[]`

`test`命令可以在`if-then`或`if-then-else`语句中测试不同的条件，如果`test`命令列出的条件成立，则返回退出状态码0。格式如下：

```shell
if test condition
then
	CMDs
else
	CMDs
fi
```

如果condition部分为空，则`test`返回非0状态码并执行`else`语句。

使用`[]`同样可以定义测试条件，格式为`if [ condition ]`。必须注意空格。

#### (1) 数值比较

bash shell中的条件测试只能用于处理**整数**。

| 参数        | 描述                   | 相关                         |
| ----------- | ---------------------- | ---------------------------- |
| n1 `-eq` n2 | 检查n1是否等于n2       | eq: equal to                 |
| n1 `-ge` n2 | 检查n1是否大于或等于n2 | ge: greater than or equal to |
| n1 `-gt` n2 | 检查n1是否大于n2       | gt: greater than             |
| n1 `-le` n2 | 检查n1是否小于或等于n2 | le: less than or equal to    |
| n1 `-lt` n2 | 检查n1是否小于n2       | lt: less than                |
| n1 `-ne` n2 | 检查n1是否不等于n2     | ne: not equal to             |

#### (2) 字符串比较

比较字符串实质上是比较字符的Unicode编码值。编码值更小的字符比编码值更大的字符小。由于`<`和`>`会被shell视为重定向符，因此必须转义。例如：str1 `\>` str2。另外，`sort`命令使用系统的语言环境设置中定义的顺序排序。对于英语，在字符串排序时，大写字母被视为大于小写字母，因此排在小写字母后。这点与`test`命令相反。

| 运算符         | 描述                   |
| -------------- | ---------------------- |
| str1 `=` str2  | 检查str1是否和str2相同 |
| str1 `!=` str2 | 检查str1是否和str2不同 |
| str1 `\<` str2 | 检查str1是否小于str2   |
| str1 `\>` str2 | 检查str1是否大于str2   |
| `-n` str1      | 检查str1长度是否不为0  |
| `-z` str1      | 检查str1长度是否为0    |

在检查字符串长度是否为0时，未定义的变量长度同样会被视为0。

#### (3) 文件比较

| 命令              | 描述                                   |
| ----------------- | -------------------------------------- |
| `-d` file         | 检查file是否存在且为目录               |
| `-e` file         | 检查file是否存在                       |
| `-f` file         | 检查file是否存在且为文件               |
| `-r` file         | 检查file是否存在且可读                 |
| `-s` file         | 检查file是否存在且非空                 |
| `-w` file         | 检查file是否存在且可写                 |
| `-x` file         | 检查file是否存在且可执行               |
| `-O` file         | 检查file是否存在且属当前用户所有       |
| `-G` file         | 检查file是否存在且默认组与当前用户相同 |
| file1 `-nt` file2 | 检查file1是否比file2新（创建时间更晚） |
| file1 `-ot` file2 | 检查file1是否比file2旧（创建时间更早） |

### 4. 复合条件测试

`if-then`语句允许使用布尔逻辑将测试条件组合起来。格式为`[ condition1 ] && [ condition2 ]`（表示AND，有0则0）和`[ condition1 ] || [ condition2 ]`（表示OR，有1则1）。

### 5. `if-then`高级特性

shell提供了可在`if-then`语句使用的3个高级特性。

1. 单括号，格式`if (CMD)`。允许在`if`语句中使用子shell。

2. 双括号，格式`((CMD))`。允许在比较过程中使用高级数学表达式，包括自增`++`、自减`--`、逻辑求反`!`、位求反`~`、幂运算`**`、左移`<<`、右移`>>`、位布尔`&`，`|`，逻辑布尔`&&`，`||`。双括号中的大于号不用转义。

3. 双方括号，格式`[[expression]]`。允许进行模式匹配，使用通配符或正则表达式来匹配字符串。

### 6. `case`命令

`case`命令采用列表格式将`variable`的值与`pattern`的值相比较，匹配则执行相应命令。格式如下：

```shell
case variable in
pattern1 | pattern2) CMDs1;;
pattern3) CMDs2;;
*) default CMDss;;
esac
```

### 7. `for`命令

`for`命令用于创建遍历一系列值的循环，格式如下：

```shell
for var in list
do
	CMDs
done
```

或是

```shell
for var in list; do
	CMDs
done
```

在迭代结束后，其中变量`var`的值在脚本剩余部分仍然有效。使用`for state in $(cat $file)`还可以直接读取文件中的值进行遍历，文本中的值应当各占一行。

IFS是内部字段分隔符，默认为空格、制表符、换行符。脚本语句`IFS=''`可将IFS的值临时设置为自定义的值。指定多个分隔符只需在赋值语句中将这些字符写在一起。在设置新值前，最好先保存其原值，例如使用语句`IFS_OLD=$IFS`。

`for`命令还能模仿C语言的`for`语句，格式：`for ((var assignment; condition; iteration process))`，例如`for ((a = 1; a < 10; a++))`。这种语句也可以迭代使用多个变量，循环会单独处理每个不同的变量。

可以在`for`循环的末尾，即`done`语句后添加处理其输出的语句，例如重定向到文件、排序等。

### 8. `while`命令

`while`的原理同C语言等编程语言，返回状态码为0时执行命令，不为0时结束循环。格式如下：

```shell
while test CMD
do
	CMDs
done
```

shell的`while`语句可以定义多个测试命令，只有最后一个测试命令的退出状态码会被用于决定是否结束循环。

`for`和`while`循环可以处理CSV文件，只需将IFS设为相应分隔符，将文件内容作为输入置于语句末，在语句开始使用`read -r para1 para2`命令即可。

### 9. `until`命令

`until`命令与`while`完全相反，只有返回状态码不为0时才会执行命令，为0时结束循环。格式如下：

```shell
until test CMD
do
	CMDs
done
```

`until`语句可以定义多个测试命令，只有最后一个测试命令的退出状态码会被用于决定是否结束循环。

### 10. `break`命令

跳出当前正在执行的循环。在嵌套循环中，内层的`break`命令只会跳出内层循环。使用命令`break n`可以指定要跳出的循环层级，默认n为1，即跳出当前循环。如果n=2则`break`会停止下一级的外层循环。

### 11. `continue`命令

`continue`命令可以提前中止某次循环，但不会结束整个循环。使用命令`continue n`可以指定要继续的循环层级。

## 处理用户输入

### 1. 位置参数和特殊变量

命令行参数允许运行脚本时在命令行中添加数据。shell会将所有命令行参数都指派给位置参数，其名称都是标准数字。`$0`对应脚本名，`$1`对应第一个命令行参数，以此类推直到`$9`。第10个参数开始需要在数字周围添加花括号，例如`${10}`。`basename`命令返回不带路径的脚本名，如`basename $0`。

shell加入的特殊变量`$#`含有脚本运行时携带的命令行参数的个数。但用在花括号中时必须换成`!`，即`${!#}`，表示最后一个位置变量。当命令行没有参数时，`$#`的值为0。（注：似乎在kali linux中不生效）

`$*`变量会将所有的命令行参数视为一个单词。`$@`变量将所有的命令行参数视为同一字符串中的多个独立的单词，可使用`for`命令遍历。

### 2. `shift`命令

`shift`命令根据命令行参数的相对位置进行移动，默认将每个位置的变量值向左移动1个位置，即`$3`的值移入`$2`，`$2`的值移入`$1`等，但`$1`的值会被删除（无法再次恢复），而`$0`的值不变。格式`shift n`表示一次性移动多个位置。

### 3. `getopt`和`getopts`命令

`getopt`命令可以接受一系列任意形式的命令行选项和参数，并自动将其转换成适当的格式。格式：`getopt optSTR paras`。`optSTR`字段定义有效的命令行选项字母，以及哪些选项字母需要参数值，在每个需要参数值的选项字母后加一个冒号，并自动插入双连字符来分隔命令行中额外的参数。例如：`getopt ab:cd -a -b BValue -cd test1 test2`。使用可选项`-q`可忽略错误消息。

`getopts`命令是`getopt`的扩展版本，每次只处理一个检测到的命令行参数，在处理完所有参数后退出并返回一个**大于0**的退出状态码。格式：`getopts optSTR variable`。在`optSTR`中最开头添加冒号可以不显示错误消息。`getopts`命令要哦用到两个环境变量，如`getopts :ab:c opt`。其中`opt`，或`OPTARG`用于保存选项所带的参数值。在解析命令行选项，如`-a, -b`时，`getopts`会移除起始的连字符，所以在`case`判断语句中不用连字符。还可以不在选项与参数之间添加空格，直接写在一起。`optSTR`中未定义的选项字母会以问号形式传给脚本。处理完选项后，可以使用`shift`命令和`OPTIND`值来移动参数，如`shift $ [ $OPTIND - 1 ]`。

某些Linux选项已经具有标准含义，添加这些选项可以更具用户友好性。

### 4. `read`命令

`read`命令从标准输入（键盘）或另一个文件描述符中接受输入。获取输入后将数据存入变量。格式`read var(s)`。

可选项`-p`允许直接指定提示符，如`read -p MSG var(s)`，将两个语句合为一句。可指定多个变量，也可不指定变量。不指定变量时，`read`会将接收到的所有数据都放进特殊变量`REPLY`中。

可选项`-t`指定输入计时器，单位为秒。超时后`read`命令返回非0退出状态码。如`read -t seconds -p MSG var`。

可选项`-s`避免`read`输入的数据出现在屏幕上。

（注：在某些shell中不支持`read`命令的交互选项，此时需要使用`bash`命令。）

`read`命令可以用来读取文件，一次读一行。通常方法是用`cat`命令获取内容后通过管道传给含有`read`命令的`while`命令。

## 呈现数据

### 1. 3个默认文件描述符

Linux用文件描述符来标识整个文件对象。bash shell保留了3个文件描述符（0、1和2），分别对应`STDIN`（标准输入），`STDOUT`（标准输出）和`STDERR`（标准错误）。`STDIN`对终端来说就是键盘，也可以使用重定向符`<`将输入重定向到指定的文件。常用命令如`cat`。`STDOUT`对终端来说就是终端显示器，也可以使用重定向符`>`将输出重定向到指定的文件，或是使用`>>`将数据追加到某个文件。但`STDOUT`并不会将错误信息重定向到文件。`STDERR`代表shell的标准错误输出，在默认情况下与`STDOUT`指向的位置一样，但可以对其进行重定向。一种是只重定向错误，使用重定向符`>`即可。要注意`>`必须紧挨着`STDERR`的文件描述符2，即`2>`。另一种是重定向错误消息和正常输出。如果要分别重定向到不同文件，则要使用**两个重定向符**，并在其之前放上相应的描述符，如`ls -la test badtest 2>err_file 1>stdout_file`。如果只需要重定向到同一个文件，则使用重定向符`&>`。

将一条自定义的错误消息重定向到`STDERR`可以使用`>&2`。

`exec`命令会启动一个新shell并将`STDOUT`文件描述符重定向到指定文件，将脚本中送往`STDOUT`的所有输出重定向，如`exec 2>testerror`。同样可以重定向`STDIN`到其他位置，如`exec 0<testfile`，通常和`read`命令相配合。

### 2. 6个替代性文件描述符

这些描述符序号从3到8。可以用`exec`命令分配用于输出的文件描述符，一旦将其指向文件就会一直有效，直到重新分配。如`exec 3>test`。或追加性的`exec 3>>test`。在后续语句中，应当有语句包含`>&3`运算符，以将该语句输出到指定文件。

恢复已重定向的文件描述符的方法是，现将另一个文件描述符分配给标准文件描述符，反之亦可，如`exec 3>&1`。然后再利用该文件描述符恢复，如`exec 1>&3`。

还可以使用同一个文件描述符兼做输入和输出，从而对文件进行读和写，如`exec 3<> test`。

使用`&-`可以关闭文件描述符，如`exec 3>&-`。如果在关闭文件描述符后重新打开该输出文件，则shell会用一个新文件来替换已有文件。这意味着如果输出数据，它就会覆盖已有文件。

### 3. `lsof`命令

`lsof`命令会列出整个Linux系统打开的所有文件描述符，包括所有后台进程和登录用户打开的文件。可选项`-p`允许指定进程ID（PID），可选项`-d`允许指定要显示的文件描述符编号，多个编号之间以逗号分隔。特殊变量`$$`可以获取进程的当前PID。可选项`-a`可用于另外两个选项的结果执行AND运算。

### 4. `null`文件

将`STDERR`重定向到一个名为`null`文件（格式`>/dev/null`）的特殊文件可以将脚本作为后台进程运行，并且不显示脚本输出。重定向到`null`文件的任何数据都会被丢弃。将`null`文件作为输入重定向，即`cat /dev/null > file`可以用来快速清除现有文件中的数据，例如日志文件。

### 5. `/tmp`目录

`/tmp`是存放临时文件的目录，任何用户都有权读写其中的文件。`mktemp`命令可以直接在`/tmp`目录中创建唯一的临时文件，该文件不使用`umask`值。

命令`mktemp filenameXXX`在本地目录创建一个文件，其中末尾的`X`数量至少要3个以上且前面没有空格，用于随机替换为同等数量的字符以保证文件名唯一性。`filename`可以包含任意文本字符。该命令只返回文件名

可选项`-t`强制在系统临时目录中创建文件。该命令返回完整路径。

可选项`-d`创建一个临时目录，格式`mktemp -dt filenameXXX`在`/tmp`文件中创建一个文件夹。

### 6. `tee`命令

格式`tee filename`。该命令将来自`STDIN`的数据同时送往`STDOUT`和所指定的文件名。可以配合管道符号来重定向命令输出。`tee`命令会在每次使用时覆盖指定文件的原先内容。可选项`-a`将数据追加到指定文件。

## 脚本控制

### 1. 常用信号

Linux常用信号如下：

| 信号 | 值        | 描述                                                         |
| ---- | --------- | ------------------------------------------------------------ |
| 1    | `SIGHUP`  | 挂起（hang up）进程                                          |
| 2    | `SIGINT`  | 中断（interrupt）进程（在shell中按下`Ctrl+C`组合键可生成）   |
| 3    | `SIGQUIT` | 停止（stop）进程                                             |
| 9    | `SIGKILL` | 无条件终止（terminate）进程（使用`kill -9`命令发送）         |
| 15   | `SIGTERM` | 尽可能终止进程                                               |
| 18   | `SIGCONT` | 继续运行停止的进程                                           |
| 19   | `SIGSTOP` | 无条件停止，但不终止进程                                     |
| 20   | `SIGTSTP` | 停止或暂停（pause），但不终止进程（在shell中按下`Ctrl+Z`组合键可生成，随后可用`ps`查看） |

bash shell默认忽略任何收到的`SIGQUIT`（3）信号和`SIGTERM`（15）信号，但会处理收到的所有`SIGHUP`（1）和`SIGINT`（2）信号。shell会将这些信号传给shell脚本处理，而shell脚本的默认行为是忽略这些信号，因为可能不利于脚本运行。在有已停止脚本的情况下退出shell需要输入两次`exit`命令。第一次提示还有已停止的脚本，第二次直接退出。

### 2. `trap`命令

`trap`命令指定shell脚本需要侦测并拦截的Linux信号。如果脚本收到了其中列出的信号，则该信号不再由shell处理，而是由本地处理。格式`trap CMDs signals`。如果脚本中的命令被信号中断，则使用带指定命令的`trap`未必能使其继续执行。因此通常使用带空操作的命令`trap "" signals`来使脚本完全忽略信号。捕获脚本退出的命令为`trap CMDs EXIT`，提前退出也可捕获。

在脚本不同位置使用选项不同的`-trap`命令可以进行不同的信号捕获处理。例如，循环前的`trap`和循环后的`trap`根据脚本运行阶段的不同输出结果也不同。在交互式shell中使用可选项`-p`可以查看被捕获的信号，如果值为空，则表示按照默认方式处理信号。

使用`trap -- signals`或`trap - signal`可以移除设置的信号捕获并恢复默认行为。

### 3. 后台运行脚本

在脚本名之后加上`&`会将脚本作为一个独立的后台进程运行，这种方法可以运行多个后台作业。在终端会话中启动的后台进程与终端相关联，终端会话退出则后台进程也会退出。

使用`nohup`命令能阻断发给特定进程的`SIGHUP`信号，解除终端与进程之间的关联。这样即使退出终端会话，进程也不会退出。格式`nohup CMD`。使用该命令后，进程不再同`STDOUT`和`STDERR`相绑定，这些消息将重定向到一个名为`nohup.out`的文件中。这个文件一般在当前工作目录或`$HOME`中创建。如果`nohup`运行了多个命令，这些命令的输出都会被追加到同一个`nohup.out`文件中。使用`jobs`命令可以处理这些作业。使用`kill -9 PID`可以删除已停止的作业。

使用`bg`命令以后台模式重启已停止的作业。存在多个作业时，需要在`bg`命令后加上作业号，如`bg 2`。

使用`fg`命令以前台模式重启已停止的作业，需要加上作业号。

### 4. 调整优先级

优先级的取值范围是-20到+19，其中-20优先级最高。默认情况下shell以优先级0启动所有进程。

使用`nice`命令可以在启动命令时设置其调度优先级。可选项`-n`让命令以更低的优先级运行。`ps`中的`ni`一列显示优先级。但只有root用户才能提高作业的优先级。

使用`renice`命令可以修改已运行命令的优先级。格式`renice -n NI -p PID`。

### 5. `at`命令

命令`at`指定Linux系统何时运行脚本。其守护进程`atd`在后台运行，默认每60秒检查一次一个特殊目录（通常是`/var/spool/at`或`/var/spool/cron/atjobs`）以获取`at`命令提交的作业。`at`命令格式为`at [-f filename] time`。如果指定的时间已经过去，那么会在第二天的同一时刻运行作业。

`at`命令可用的时间和日期格式参考`/usr/share/doc/at/timespec`文件。该命令会将作业提交到作业队列，作业队列通常用小写字母a~z和大写字母A~Z指代，一共有52种。`batch`命令（`/usr/bin/batch`）会调用`at`命令将作业提交到b队列中。`at`命令默认将作业放入a队列。可选项`-q`指定其他的队列，z队列相对于其他队列少占CPU。

Linux默认会将`at`命令的`STDOUT`和`STDERR`发送到用户email地址，可以在脚本中对其重定向。可选项`-M`禁止作业发送邮件。

`atq`命令可以查看系统中有哪些作业在等待。`atrm`命令+作业号可以指定删除等待中的作业。但只能删除自己提交的作业。

### 6. `cron`程序

`cron`程序可以调度需要定期执行的作业。该程序从`cron`时间表中获知已安排执行的作业。`cron`时间表的格式为：`minutepasthour hourofday dayofmonth month dayofweek CMD`，允许使用特定值、取值范围或通配符（`*`）来指定各个字段。例如，每天10:15执行该程序则设置为`15 10 * * * CMD`（24小时制）。可以使用三字符的文本值（mon, tue, wed, thu, fri, sat, sun）或数值（0或7代表周日，6代表周六）指定`dayofweek`字段。

`dayofmonth`指月份中的日期值（1~31）。通过设置`if-then`语句，使用`date`命令检查明天的日期是不是某个月份的第一天（01），可以将命令设在每个月的最后一天执行。例如：`00 12 28-31 * * if [ "$(date +%d -d tomorrow)" = 01 ]; then CMD; fi`。该脚本在每天中午12点检查当天是不是当月的最后一天。另一种方法是将`CMD`替换成一个包含`if-then`语句的控制脚本，在可能是每月最后一天的时候运行。命令列表必须指定完整路径。

`crontab`程序可以处理`cron`时间表。可选项`-l`列出已有的`cron`时间表。默认情况下，用户的`cron`时间表文件并不存在，可以用可选项`-e`向内添加字段。

还可使用5个预配置的`cron`脚本目录：`/etc/cron.hourly`、`/etc/cron.daily`、`/etc/cron.monthly`、`/etc/cron.weekly`和`/etc/cron.yearly`。

### 7. `anacron`程序

`anacron`程序会自动判断作业是否由于系统关闭等原因错过了设置的运行时间，并尽快运行该作业。也就是说，原计划在Linux系统关闭期间运行的作业在开机后自动运行。该程序只处理位于`cron`目录的程序（不会运行`/etc/cron.hourly`目录的脚本，因为时间需求少于一天），它通过时间戳来判断作业是否在正确的计划间隔内运行。每个`cron`目录的时间戳文件存放于`/var/spool/anacron`。

`anacron`程序使用自己的时间表（`/etc/anacrontab`）来检查作业目录。`anacron`时间表的格式为：`period delay identifier CMD`。`period`字段定义作业运行频率（以天为单位），用于检查作业的时间戳文件。`delay`字段指定在系统启动后到开始运行的等待分钟数。`identifier`字段是非空字段，值包括`cron.daily`等。`CMD`字段包含一个`run-parts --report`程和一个`cron`脚本目录名。

### 8. 使用新shell启动脚本

当用户登录bash shell时会运行的启动文件通常包括`$HOME/.bash_profile`，`$HOME/.bash_login`和`$HOME/.profile`。而`$HOME/.bashrc`是由非登录shell运行的文件。

`source`命令也可以运行shell脚本，但不会创建子shell。

## 创建函数

bash shell中创建函数的语法有两种。第一种是使用关键字`function`，格式：

```shell
function name {
	CMDs
}
```

第二种的格式：

```shell
name() {
	CMDs
}
```

只需要写出函数名即可调用函数。

### 1. 退出状态码

shell中的函数被视为一个小型脚本，运行结束时会返回一个退出状态。有3种方法能生成退出状态码，使用`$?`命令可以查看最后执行的命令的退出状态码。默认情况下，函数的退出状态码是函数中最后一个命令返回的退出状态码。但由于函数中命令执行失败也会继续向下执行，所以这种方法无法获知之前的命令是否成功执行。

`return`命令能以特定的整数值退出状态码退出函数。这个整数必须介于0~255，否则会出错。

可以将函数的输出赋给变量，例如`result=$(dbl)`，其中`dbl`是个函数。这样就可以突破`return`命令整数范围的限制，还可以返回浮点值和字符串。

### 2. 参数与变量

向函数传递参数的格式为`func $var value`，必须在shell脚本内预设，函数只通过位置变量访问参数，无法直接获取脚本的命令行参数。要在函数中使用脚本命令行参数，必须在调用函数时手动传入，例如`func $1 $2`。

默认情况下，在函数外定义的任何变量都是全局变量。在函数内部使用`local`关键字可将变量声明为局部变量。

### 3. 数组

向函数传入数组时，必须先将数组变量拆解成多个数组元素，然后将这些元素作为函数参数传递。最后在函数内部将所有参数重新组合成一个新的数组变量。样例如下：

```shell
function test {
	local newarray
	newarray=('echo "$@"')
	# 处理该数组
	...
}

myarray=(1 2 3 4 5)
test ${myarray[*]}
```

函数局部变量`newarray`接收`myarray`中的所有数组元素并进一步处理。

函数返回数组时方式类似。先用`echo`语句按正确顺序输出数组的各个元素，然后脚本再将数组元素重组成一个新的数组变量。

### 4. 递归

函数可以递归调用，典型例子为阶乘。

```shell
function factorial {
	if [ $1 -eq 1 ]
	then
		echo 1
	else
		local temp=$[ $1 - 1 ]
		local result=`factorial $temp`
		echo $[ $result * $1 ]
	fi
}
```

### 5. 库

库可以使得同一段代码可以在多个脚本中使用。可以使用`source`命令的别名**点号操作符**`.`使脚本可以调用库中的函数。例如，库文件名为`myfuncs`，使用命令`. ./myfuncs`即可调用该库。

### 6. 命令行函数

在shell中定义函数就可以在整个系统的任意目录中使用它。

有两种方法在命令行中直接定义函数。第一种是采用单行方式定义，如`$ function name{ CMDs; }`，必须在每条命令后加分号。这种单行定义可以在函数体中跨行。例如：

```shell
$ funtion name{ CMD1; 
CMD2; }
```

另一种是采用多行方式定义函数，无需在命令末尾放置分号，格式如下：

```shell
$ funtion name {
> CMD
> }
```

在命令行创建函数时如果函数名与另一个命令（如内建命令）相同，则函数会覆盖原来的命令。且退出shell后，函数也会消失。

可以在`.bashrc`文件中定义函数，使得每次启动shell都能调用。在shell脚本中可使用`source`命令或其别名`.`将库文件中的函数添加到`.bashrc`脚本中。例如：

```shell
if [ -r /etc/bashrc ] then
	. /etc/bashrc
fi

. /home/rich/libraries/myfuncs
```

这些函数还会传给子进程。

### 7. GNU shtool shell脚本函数库

这个库提供了一些简单现成的shell脚本函数。格式`shtool [options] [function [options] [args]]`。可以在命令行和脚本中直接使用`shtool`函数。
